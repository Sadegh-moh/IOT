"""
IoT Device model for IoT Edge Computing Real-Time Scheduling System
Represents an IoT device that generates tasks and communicates with edge servers
"""

import uuid
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
from enum import Enum
import random
import math
from .task import Task, TaskType, TaskStatus


class DeviceType(Enum):
    """IoT device type enumeration"""
    SENSOR = "sensor"
    ACTUATOR = "actuator"
    GATEWAY = "gateway"
    CAMERA = "camera"
    SMART_DEVICE = "smart_device"


class DeviceStatus(Enum):
    """Device status enumeration"""
    ACTIVE = "active"
    IDLE = "idle"
    OFFLINE = "offline"
    MAINTENANCE = "maintenance"
    ERROR = "error"


@dataclass
class IoTDevice:
    """
    IoT Device model representing a device that generates tasks
    
    Attributes:
        device_id: Unique identifier for the device
        device_type: Type of IoT device
        location: Geographic location coordinates
        status: Current status of the device
        generated_tasks: List of tasks generated by this device
        received_results: Dictionary of task results received from edge servers
        communication_latency: Network latency to decision unit
        energy_consumption: Current energy consumption
        battery_level: Battery level (0.0-1.0)
        task_generation_rate: Rate at which tasks are generated
        last_task_time: Timestamp of last task generation
        performance_metrics: Dictionary of performance metrics
    """
    
    device_id: str
    device_type: DeviceType
    location: tuple
    status: DeviceStatus = DeviceStatus.ACTIVE
    generated_tasks: List[Task] = field(default_factory=list)
    received_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    communication_latency: float = 0.0
    energy_consumption: float = 0.0
    battery_level: float = 1.0
    task_generation_rate: float = 0.01
    last_task_time: float = 0.0
    performance_metrics: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Initialize default values after object creation"""
        if not self.device_id:
            self.device_id = str(uuid.uuid4())
        if self.communication_latency == 0.0:
            # Random communication latency between 1-5 time units
            self.communication_latency = random.uniform(1, 5)
    
    def generate_task(self, current_time: float, task_config: dict) -> Optional[Task]:
        """
        Generate a new task based on device type and configuration
        
        Args:
            current_time: Current simulation time
            task_config: Configuration for task generation
            
        Returns:
            Generated task or None if generation fails
        """
        # Check if device can generate tasks
        if self.status != DeviceStatus.ACTIVE:
            return None
        
        # Check battery level
        if self.battery_level < 0.1:
            return None
        
        # Check generation rate
        if current_time - self.last_task_time < 1.0 / self.task_generation_rate:
            return None
        
        # Generate task parameters based on device type
        task_params = self._generate_task_parameters(task_config)
        
        # Create task
        task = Task(
            task_id=f"{self.device_id}_task_{len(self.generated_tasks)}",
            task_type=task_params['task_type'],
            execution_time=task_params['execution_time'],
            deadline=task_params['deadline'],
            period=task_params['period'],
            utilization=task_params['utilization'],
            profit=task_params['profit'],
            penalty=task_params['penalty'],
            arrival_time=current_time
        )
        
        # Calculate priority
        task.calculate_priority('mbpt')
        
        # Add to generated tasks
        self.generated_tasks.append(task)
        self.last_task_time = current_time
        
        # Update energy consumption
        self._update_energy_consumption(0.1)  # Small energy cost for task generation
        
        return task
    
    def _generate_task_parameters(self, task_config: dict) -> Dict[str, Any]:
        """
        Generate task parameters based on device type
        
        Args:
            task_config: Base task configuration
            
        Returns:
            Dictionary with task parameters
        """
        # Get configuration ranges
        exec_range = task_config['execution_time_range']
        deadline_range = task_config['deadline_range']
        period_range = task_config['period_range']
        profit_range = task_config['profit_range']
        penalty_range = task_config['penalty_range']
        utilization_range = task_config['utilization_range']
        
        # Adjust parameters based on device type
        if self.device_type == DeviceType.SENSOR:
            # Sensors generate small, frequent tasks
            execution_time = random.uniform(exec_range[0], exec_range[1] * 0.3)
            period = random.uniform(period_range[0], period_range[1] * 0.5)
            profit = random.uniform(profit_range[0], profit_range[1] * 0.6)
            utilization = random.uniform(utilization_range[0], utilization_range[1] * 0.5)
            task_type = TaskType.SOFT_REAL_TIME
            
        elif self.device_type == DeviceType.ACTUATOR:
            # Actuators generate medium tasks with strict deadlines
            execution_time = random.uniform(exec_range[0] * 0.5, exec_range[1] * 0.7)
            period = random.uniform(period_range[0] * 0.8, period_range[1] * 1.2)
            profit = random.uniform(profit_range[0] * 0.8, profit_range[1] * 1.0)
            utilization = random.uniform(utilization_range[0] * 0.7, utilization_range[1] * 0.9)
            task_type = TaskType.HARD_REAL_TIME
            
        elif self.device_type == DeviceType.CAMERA:
            # Cameras generate large, data-intensive tasks
            execution_time = random.uniform(exec_range[0] * 1.5, exec_range[1] * 2.0)
            period = random.uniform(period_range[0] * 1.5, period_range[1] * 2.0)
            profit = random.uniform(profit_range[0] * 1.2, profit_range[1] * 1.5)
            utilization = random.uniform(utilization_range[0] * 1.1, utilization_range[1] * 1.0)
            task_type = TaskType.SOFT_REAL_TIME
            
        elif self.device_type == DeviceType.GATEWAY:
            # Gateways generate mixed task types
            execution_time = random.uniform(exec_range[0] * 0.8, exec_range[1] * 1.2)
            period = random.uniform(period_range[0] * 0.9, period_range[1] * 1.1)
            profit = random.uniform(profit_range[0] * 0.9, profit_range[1] * 1.1)
            utilization = random.uniform(utilization_range[0] * 0.8, utilization_range[1] * 0.9)
            task_type = random.choice([TaskType.HARD_REAL_TIME, TaskType.SOFT_REAL_TIME])
            
        else:  # SMART_DEVICE
            # Smart devices generate varied tasks
            execution_time = random.uniform(exec_range[0], exec_range[1])
            period = random.uniform(period_range[0], period_range[1])
            profit = random.uniform(profit_range[0], profit_range[1])
            utilization = random.uniform(utilization_range[0], utilization_range[1])
            task_type = random.choice([TaskType.HARD_REAL_TIME, TaskType.SOFT_REAL_TIME])
        
        # Generate deadline based on task type
        if task_type == TaskType.HARD_REAL_TIME:
            deadline = random.uniform(execution_time, period)
        else:
            deadline = random.uniform(period * 0.8, period * 1.5)
        
        # Generate penalty proportional to profit
        penalty = random.uniform(penalty_range[0], penalty_range[1])
        penalty = min(penalty, profit * 0.8)
        
        return {
            'task_type': task_type,
            'execution_time': execution_time,
            'deadline': deadline,
            'period': period,
            'utilization': utilization,
            'profit': profit,
            'penalty': penalty
        }
    
    def receive_task_result(self, task_id: str, result: Dict[str, Any], current_time: float):
        """
        Receive result from edge server for a completed task
        
        Args:
            task_id: ID of the completed task
            result: Result data from edge server
            current_time: Current simulation time
        """
        # Store result
        self.received_results[task_id] = {
            'result': result,
            'receive_time': current_time,
            'latency': current_time - result.get('completion_time', current_time)
        }
        
        # Update task status
        for task in self.generated_tasks:
            if task.task_id == task_id:
                if result.get('success', False):
                    print(f"Task {task.task_id} completed at time {result.get('completion_time')}")
                    task.update_status(TaskStatus.COMPLETED, result.get('completion_time'))
                else:
                    task.update_status(TaskStatus.FAILED, current_time)
                break
        
        # Update performance metrics
        self._update_performance_metrics(task_id, result)
    
    def _update_performance_metrics(self, task_id: str, result: Dict[str, Any]):
        """
        Update device performance metrics
        
        Args:
            task_id: ID of the task
            result: Task result
        """
        if 'total_tasks' not in self.performance_metrics:
            self.performance_metrics['total_tasks'] = 0
            self.performance_metrics['completed_tasks'] = 0
            self.performance_metrics['failed_tasks'] = 0
            self.performance_metrics['total_profit'] = 0.0
            self.performance_metrics['total_latency'] = 0.0
        
        self.performance_metrics['total_tasks'] += 1
        
        if result.get('success', False):
            self.performance_metrics['completed_tasks'] += 1
            self.performance_metrics['total_profit'] += result.get('profit_loss', 0.0)
        else:
            self.performance_metrics['failed_tasks'] += 1
        
        # Update latency metrics
        if 'completion_time' in result:
            task = next((t for t in self.generated_tasks if t.task_id == task_id), None)
            if task:
                latency = result['completion_time'] - task.arrival_time
                self.performance_metrics['total_latency'] += latency
    
    def _update_energy_consumption(self, energy_cost: float):
        """
        Update device energy consumption
        
        Args:
            energy_cost: Energy cost for current operation
        """
        self.energy_consumption += energy_cost
        
        # Reduce battery level
        self.battery_level = max(0.0, self.battery_level - energy_cost * 0.01)
        
        # Update status based on battery level
        if self.battery_level < 0.1:
            self.status = DeviceStatus.ERROR
        elif self.battery_level < 0.3:
            self.status = DeviceStatus.MAINTENANCE
    
    def get_success_rate(self) -> float:
        """
        Calculate task success rate
        
        Returns:
            Success rate (0.0-1.0)
        """
        if not self.performance_metrics or self.performance_metrics['total_tasks'] == 0:
            return 0.0
        
        return self.performance_metrics['completed_tasks'] / self.performance_metrics['total_tasks']
    
    def get_average_latency(self) -> float:
        """
        Calculate average task latency
        
        Returns:
            Average latency in time units
        """
        if not self.performance_metrics or self.performance_metrics['completed_tasks'] == 0:
            return 0.0
        
        return self.performance_metrics['total_latency'] / self.performance_metrics['completed_tasks']
    
    def get_total_profit(self) -> float:
        """
        Get total profit from completed tasks
        
        Returns:
            Total profit
        """
        return self.performance_metrics.get('total_profit', 0.0)
    
    def to_dict(self) -> dict:
        """
        Convert device to dictionary representation
        
        Returns:
            Dictionary representation of the device
        """
        return {
            'device_id': self.device_id,
            'device_type': self.device_type.value,
            'location': self.location,
            'status': self.status.value,
            'generated_tasks_count': len(self.generated_tasks),
            'received_results_count': len(self.received_results),
            'communication_latency': self.communication_latency,
            'energy_consumption': self.energy_consumption,
            'battery_level': self.battery_level,
            'task_generation_rate': self.task_generation_rate,
            'success_rate': self.get_success_rate(),
            'average_latency': self.get_average_latency(),
            'total_profit': self.get_total_profit()
        }
    
    def __str__(self) -> str:
        """String representation of the device"""
        return (f"IoTDevice(id={self.device_id}, type={self.device_type.value}, "
                f"status={self.status.value}, battery={self.battery_level:.2f})")
    
    def __repr__(self) -> str:
        """Detailed string representation of the device"""
        return self.__str__()
